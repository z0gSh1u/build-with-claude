# 06g - 缓存实践

## 提示缓存的工作原理

当你启用提示缓存时，第一个请求会将内容写入一个持续一小时的生命周期的缓存中。后续请求可以从此缓存中读取，而不是再次处理相同的内容。这在发送以下内容时尤其有价值：

- 大型系统提示（如一个 6K token 的编程助手提示）
- 复杂的工具模式（多个工具大约需要 1.7K 个标记）
- 重复的消息内容

缓存只有在反复发送相同内容时才有效——但在许多应用中，这种情况非常频繁发生。

## 缓存工具 Schema

```python
if tools:
    tools_clone = tools.copy()
    last_tool = tools_clone[-1].copy()
    last_tool["cache_control"] = {"type": "ephemeral"}
    tools_clone[-1] = last_tool
    params["tools"] = tools_clone
```

## 缓存系统提示词

```python
if system:
    params["system"] = [
        {
            "type": "text",
            "text": system,
            "cache_control": {"type": "ephemeral"}
        }
    ]
```

这会把你系统提示从简单字符串转换为支持缓存的格式。

## 缓存的行为

当你运行启用缓存的请求时，你会在响应中看到不同的使用模式：

- 首次请求： `cache_creation_input_tokens=1772` - Claude 写入缓存
- 后续请求： `cache_read_input_tokens=1772` - Claude 从缓存读取
- 内容变更：新缓存创建令牌出现

缓存非常敏感——即使工具或系统提示中更改单个字符，也会使该组件的整个缓存失效。

## 缓存排序和断点

您可以在单个请求中设置多个缓存断点。顺序很重要：

- 工具（如果提供）
- 系统提示（如果提供）
- 消息

如果你更改系统提示但保持相同的工具，你会看到部分缓存读取（针对工具）和缓存写入（针对新的系统提示）。这种细粒度缓存意味着你只需为实际更改的部分付费。

当您拥有以下情况时，提示缓存最为有效：

- 跨请求一致的工具模式
- 稳定的系统提示
- 使用相似上下文进行多次请求的应用程序

请记住，缓存仅持续一小时，因此它是为频繁使用 API 的应用程序设计的。

